# Лабораторная работа №3
Все задания лабораторной работы выполненны в PostgreSQL
## Описание схемы базы данных
Состоит из 4-х таблиц:
- Покупатель (customer)
  | id | surname | city | discount |
  |----|---------|------|----------|
- Агент (agent)
  | id | surname | city | commission_fee |
  |----|---------|------|----------------|
- Товар (product)
  | id | product_name | price | warehouse_city | maximum_number |
  |----|--------------|-------|----------------|----------------|
- Покупка\презентация (purchase_presentation)
  | number | date | customer_id | agent_id | product_id | quantity | price |
  |--------|------|-------------|----------|------------|----------|-------|
Для каждой таблицы первый столбец является *первичным ключом*. При этом таблица "Покупка" (purchase) содержит три *внешних ключа*: customer_id, agent_id, product_id.
## Задание №1
**Формулировка**: *Дана схема базы данных в виде следующих отношений. С помощью операторов SQL создать логическую структуру соответствующих таблиц для хранения в СУБД, используя известные средства поддержания целостности (NOT NULL, UNIQUE, и т.д.). Обосновать выбор типов данных и используемые средства поддержания целостности. При выборе подходящих типов данных использовать информацию о конкретных значениях полей БД (см. прил.1)*

**Решение на SQL**:
```SQL
CREATE TABLE customer
(
	id INTEGER PRIMARY KEY CHECK (id > 0),
	surname TEXT NOT NULL,
	address TEXT NOT NULL,
	discount INTEGER NOT NULL CHECK (discount BETWEEN 0 AND 100)
);

CREATE TABLE agent
(
	id INTEGER PRIMARY KEY CHECK (id > 0),
	surname TEXT NOT NULL,
	city TEXT NOT NULL,
	commission_fee INTEGER NOT NULL CHECK (commission_fee BETWEEN 0 AND 100)
);

CREATE TABLE product
(
	id INTEGER PRIMARY KEY CHECK (id > 0),
	product_name TEXT NOT NULL,
	price INTEGER NOT NULL CHECK (price > 0),
	warehouse_city TEXT NOT NULL,
	maximum_number INTEGER NOT NULL CHECK (maximum_number > 0)
);

CREATE TYPE Months AS ENUM 
('Январь', 
'Февраль',
'Март',
'Апрель',
'Май',
'Июнь',
'Июль',
'Август',
'Сентябрь',
'Октябрь',
'Ноябрь',
'Декабрь');

CREATE TABLE purchase_presentation
(
	number INTEGER PRIMARY KEY CHECK (number > 0),
	date Months NOT NULL,
	customer_id INTEGER NOT NULL,
	agent_id INTEGER NOT NULL,
	product_id INTEGER NOT NULL,
	quantity INTEGER NOT NULL CHECK (quantity > 0),
	price INTEGER NOT NULL CHECK (price > 0),
	FOREIGN KEY (customer_id) REFERENCES customer (id)
		ON UPDATE CASCADE
		ON DELETE CASCADE,
	FOREIGN KEY (agent_id) REFERENCES agent (id)
		ON UPDATE CASCADE
		ON DELETE CASCADE,
	FOREIGN KEY (product_id) REFERENCES product (id)
		ON UPDATE CASCADE
		ON DELETE CASCADE
);
```

**Результат работы в СУБД**: ![image](https://github.com/user-attachments/assets/ae1c2ff6-0d2e-4c1f-8070-3da5b75b4d62)

**Пояснения**:
1) Тип для полей id и number был выбран INTEGER с условием на положительность, так как это наиболее интуитивно подходящий тип для данного поля. Конечно, можно делать это поле текстового формата с тем расчётом, чтобы избежать проблемы переполнения, но строковые представления чисел весят иногда больше (например, число 2 млрд будет весить 4 байта в формате Integer, а строка "2.000.000.000" будет весить 10 байт) и придётся делать какую-то проверку на то, что данная строка именно число, а не что-то другое. Также для поля date в таблице purchase_presentation был создан тип Month.
2) Для всех полей установил ограничение NOT NULL (кроме первичных - там это требование заключено в ограничении PRIMARY KEY), потому что отстутствие той или иной информации может оказаться существенным для реальной модели (например, отстутвие указанного города для склада с товаром может повлечь за собой проблемы с доставкой).
3) Установил минимальные требования корректности данных при помощи ограничения CHECK. Например, скидка не может быть больше 100% (просто в целях предотвращения каких-то очень грубых случайных ошибок при заполнении базы данных).
4) Связал поля customer_id, agent_id, product_id с соответсвующими полями из таблиц customer, agent, product, а в качестве поведения изменений для каждого внешнего ключа было выбрано CASCADE для того, чтобы в случае изменения записей в основной таблице эти изменения отразились в точности и на записях связанных таблиц, точно также и удаление.

## Задание №2
**Формулировка**: *Ввести в ранее созданные таблицы конкретные данные (см. прил. 1). Использовать скрипт-файл из операторов INSERT или вспомогательную утилиту.*

**Решение на SQL**:
```SQL
INSERT INTO customer VALUES
	(001, 'Зуденкова', 'Москва', 0),
	(002, 'Россиев', 'С.-Петербург', 5),
	(003, 'Пушкина', 'Вологда', 0),
	(004, 'Роговцев', 'Иваново', 3),
	(005, 'Камышлейцева', 'Москва', 3);

INSERT INTO agent VALUES
	(001, 'Купцова', 'Москва', 4),
 	(002, 'Шадрин', 'Н.Новгород', 4),
 	(003, 'Пузанкова', 'Иваново', 3),
 	(004, 'Тукмакова', 'С.-Петербург', 4),
 	(005, 'Коротин', 'Н.Новгрод', 4),
 	(006, 'Лаптев', 'Москва', 4);

INSERT INTO product VALUES
	(001, 'Кастрюля 1л.', 10000, 'Н.Новгрод', 10),
 	(002, 'Блюдо', 5100, 'Москва', 17),
 	(003, 'Нож', 2200, 'Н.Новгрод', 22),
 	(004, 'Кастрюля 2л.', 15000, 'С.-Петербург', 8),
 	(005, 'Вилка', 2000, 'Иваново', 14),
 	(006, 'Сковорода', 9800, 'С.-Петербург', 12),
 	(007, 'Тарелка', 4000, 'Москва', 18);

INSERT INTO purchase_presentation VALUES
	(00010, 'Январь', 001, 005, 007, 3, 12000),
	(00011, 'Январь', 002, 002, 006, 2, 19600),
	(00012, 'Январь', 002, 004, 004, 1, 15000),
	(00013, 'Январь', 005, 006, 003, 3, 6600),
	(00014, 'Февраль',003, 003, 004, 1, 15000),
	(00015, 'Апрель', 005, 005, 005, 12, 60000),
	(00016, 'Май', 002, 005, 001, 2, 20000),
	(00017, 'Май', 004, 003, 004, 1, 15000),
	(00018, 'Июнь', 002, 003, 001, 2, 20000),
	(00019, 'Июнь', 005, 001, 004, 1, 15000),
	(00020, 'Июнь', 005, 006, 003, 2, 4400),
	(00021, 'Июль', 002, 004, 004, 1, 15000),
	(00022, 'Июль', 003, 002, 005, 5, 10000),
	(00023, 'Июль', 003, 002, 003, 4, 8800),
	(00024, 'Июль', 003, 004, 006, 2, 19600),
	(00025, 'Июль', 004, 006, 006, 2, 19600),
	(00026, 'Июль', 003, 002, 002, 5, 25500);
```
**Результат работы в СУБД**: ![image](https://github.com/user-attachments/assets/775232e7-fa36-4e6a-8ba4-f4bed9c991e8)

## Задание №3
**Формулировка**: *Используя оператор SELECT создать запрос для вывода всех строк каждой таблицы. Проверить правильность ввода. При необходимости произвести коррекцию значений операторами INSERT, UPDATE, DELETE*

**Решение на SQL**:
```SQL
SELECT * FROM customer;
SELECT * FROM agent;
SELECT * FROM product;
SELECT * FROM purchase_presentation;
```
**Результат работы в СУБД**: ![image](https://github.com/user-attachments/assets/ff8eae8f-9403-4a22-9233-65f11a73a2bf)

## Задание №4
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №5
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №6
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №7
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №8
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №9
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №10
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №11
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №12
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №13
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №14
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:

## Задание №15
**Формулировка**: 
**Решение на SQL**:
**Результат работы в СУБД**:
